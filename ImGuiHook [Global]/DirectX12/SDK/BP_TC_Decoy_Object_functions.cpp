#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_TC_Decoy_Object

#include "Basic.hpp"

#include "BP_TC_Decoy_Object_classes.hpp"
#include "BP_TC_Decoy_Object_parameters.hpp"


namespace SDK
{

// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.ExecuteUbergraph_BP_TC_Decoy_Object
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_TC_Decoy_Object_C::ExecuteUbergraph_BP_TC_Decoy_Object(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "ExecuteUbergraph_BP_TC_Decoy_Object");

	Params::BP_TC_Decoy_Object_C_ExecuteUbergraph_BP_TC_Decoy_Object Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.StartShots
// (BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::StartShots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "StartShots");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.TrapBrokenEffect
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::TrapBrokenEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "TrapBrokenEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.RunLoopAnimation
// (BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::RunLoopAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "RunLoopAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.LoopAnimation
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::LoopAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "LoopAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.OpenAnimation
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::OpenAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "OpenAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.EndAnimation
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::EndAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "EndAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Destroy Effect
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::Destroy_Effect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Destroy Effect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Spawn Effect
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::Spawn_Effect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Spawn Effect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Play Fire Sound
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundBase*                       Sound                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_TC_Decoy_Object_C::Play_Fire_Sound(class USoundBase* Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Play Fire Sound");

	Params::BP_TC_Decoy_Object_C_Play_Fire_Sound Parms{};

	Parms.Sound = Sound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Fire Shot B
// (BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::Fire_Shot_B()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Fire Shot B");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Fire Shot A
// (BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::Fire_Shot_A()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Fire Shot A");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Trap_Break
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Player_that_destroyed_the_trap                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_TC_Decoy_Object_C::Trap_Break(class UObject* Player_that_destroyed_the_trap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Trap_Break");

	Params::BP_TC_Decoy_Object_C_Trap_Break Parms{};

	Parms.Player_that_destroyed_the_trap = Player_that_destroyed_the_trap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Set Trap Variables Decoy
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFirearmWeaponConfiguration      WeaponA                                                (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FFirearmWeaponConfiguration      WeaponB                                                (BlueprintVisible, BlueprintReadOnly, Parm)

void ABP_TC_Decoy_Object_C::Set_Trap_Variables_Decoy(const struct FFirearmWeaponConfiguration& WeaponA, const struct FFirearmWeaponConfiguration& WeaponB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Set Trap Variables Decoy");

	Params::BP_TC_Decoy_Object_C_Set_Trap_Variables_Decoy Parms{};

	Parms.WeaponA = std::move(WeaponA);
	Parms.WeaponB = std::move(WeaponB);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Get Random Gun Sounds
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::Get_Random_Gun_Sounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Get Random Gun Sounds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.GetFireSound
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FFirearmWeaponConfiguration      Firearm                                                (BlueprintVisible, BlueprintReadOnly, Parm)
// class USoundBase*                       Sound                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_TC_Decoy_Object_C::GetFireSound(const struct FFirearmWeaponConfiguration& Firearm, class USoundBase** Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "GetFireSound");

	Params::BP_TC_Decoy_Object_C_GetFireSound Parms{};

	Parms.Firearm = std::move(Firearm);

	UObject::ProcessEvent(Func, &Parms);

	if (Sound != nullptr)
		*Sound = Parms.Sound;
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.FireShot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundBase*                       Sound                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TDelegate<void()>                       Delegate                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor)
// struct FFirearmWeaponConfiguration      Weapon                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FFireMode                        FireMode                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// int32                                   Counter                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTimerHandle                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash)
// bool                                    ResetCounter                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

struct FTimerHandle ABP_TC_Decoy_Object_C::FireShot(class USoundBase*& Sound, TDelegate<void()>& Delegate, struct FFirearmWeaponConfiguration& Weapon, struct FFireMode& FireMode, int32& Counter, bool* ResetCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "FireShot");

	Params::BP_TC_Decoy_Object_C_FireShot Parms{};

	Parms.Sound = Sound;
	Parms.Delegate = Delegate;
	Parms.Weapon = std::move(Weapon);
	Parms.FireMode = std::move(FireMode);
	Parms.Counter = Counter;

	UObject::ProcessEvent(Func, &Parms);

	Sound = Parms.Sound;
	Delegate = Parms.Delegate;
	Weapon = std::move(Parms.Weapon);
	FireMode = std::move(Parms.FireMode);
	Counter = Parms.Counter;

	if (ResetCounter != nullptr)
		*ResetCounter = Parms.ResetCounter;

	return Parms.ReturnValue;
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Activate
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Timer                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_TC_Decoy_Object_C::Activate(int32 Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Activate");

	Params::BP_TC_Decoy_Object_C_Activate Parms{};

	Parms.Timer = Timer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Trap_AutoBreak
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::Trap_AutoBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Trap_AutoBreak");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_TC_Decoy_Object.BP_TC_Decoy_Object_C.Trap_Phase_Activated
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_TC_Decoy_Object_C::Trap_Phase_Activated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_TC_Decoy_Object_C", "Trap_Phase_Activated");

	UObject::ProcessEvent(Func, nullptr);
}

}

